diff -ruN xv6-public_original/defs.h xv6-public_new/defs.h
--- xv6-public_original/defs.h	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/defs.h	2022-10-31 23:00:53.000000000 +0530
@@ -9,6 +9,7 @@
 struct sleeplock;
 struct stat;
 struct superblock;
+struct req_queue;
 
 // bio.c
 void            binit(void);
@@ -120,6 +121,17 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void 			create_kernel_process(const char *name, void (*entrypoint)());
+void 			swap_out_process_function();
+void 			swap_in_process_function();
+extern int swap_out_process_exists;
+extern int swap_in_process_exists;
+extern struct req_queue queue1;
+extern struct req_queue queue2;
+int rpush(struct proc *p);
+struct proc* rpop();
+struct proc* rpop2();
+int rpush2(struct proc* p);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -164,6 +176,7 @@
 extern uint     ticks;
 void            tvinit(void);
 extern struct spinlock tickslock;
+extern struct spinlock swap_in_lock;
 
 // uart.c
 void            uartinit(void);
@@ -185,6 +198,9 @@
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+extern 			char * sleeping_channel;
+extern struct spinlock sleeping_channel_lock;
+extern 			int sleeping_channel_count;
 
 // number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
\ No newline at end of file
diff -ruN xv6-public_original/exec.c xv6-public_new/exec.c
--- xv6-public_original/exec.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/exec.c	2022-10-31 13:43:47.000000000 +0530
@@ -6,6 +6,7 @@
 #include "defs.h"
 #include "x86.h"
 #include "elf.h"
+#include "fcntl.h"
 
 int
 exec(char *path, char **argv)
@@ -111,4 +112,4 @@
     end_op();
   }
   return -1;
-}
+}
\ No newline at end of file
diff -ruN xv6-public_original/fs.c xv6-public_new/fs.c
--- xv6-public_original/fs.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/fs.c	2022-10-31 13:44:41.000000000 +0530
@@ -331,7 +331,9 @@
 void
 iput(struct inode *ip)
 {
+
   acquiresleep(&ip->lock);
+
   if(ip->valid && ip->nlink == 0){
     acquire(&icache.lock);
     int r = ip->ref;
@@ -667,4 +669,4 @@
 nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
-}
+}
\ No newline at end of file
diff -ruN xv6-public_original/.git/config xv6-public_new/.git/config
--- xv6-public_original/.git/config	2022-08-12 23:04:14.366780000 +0530
+++ xv6-public_new/.git/config	2022-10-25 08:09:59.000000000 +0530
@@ -4,7 +4,7 @@
 	bare = false
 	logallrefupdates = true
 [remote "origin"]
-	url = https://github.com/mit-pdos/xv6-public.git
+	url = https://github.com/mit-pdos/xv6-public
 	fetch = +refs/heads/*:refs/remotes/origin/*
 [branch "master"]
 	remote = origin
diff -ruN xv6-public_original/.git/hooks/fsmonitor-watchman.sample xv6-public_new/.git/hooks/fsmonitor-watchman.sample
--- xv6-public_original/.git/hooks/fsmonitor-watchman.sample	2022-08-12 23:03:57.022407000 +0530
+++ xv6-public_new/.git/hooks/fsmonitor-watchman.sample	2022-10-25 08:09:43.000000000 +0530
@@ -8,166 +8,102 @@
 # (https://facebook.github.io/watchman/) with git to speed up detecting
 # new and modified files.
 #
-# The hook is passed a version (currently 2) and last update token
-# formatted as a string and outputs to stdout a new update token and
-# all files that have been modified since the update token. Paths must
-# be relative to the root of the working tree and separated by a single NUL.
+# The hook is passed a version (currently 1) and a time in nanoseconds
+# formatted as a string and outputs to stdout all files that have been
+# modified since the given time. Paths must be relative to the root of
+# the working tree and separated by a single NUL.
 #
 # To enable this hook, rename this file to "query-watchman" and set
 # 'git config core.fsmonitor .git/hooks/query-watchman'
 #
-my ($version, $last_update_token) = @ARGV;
-
-# Uncomment for debugging
-# print STDERR "$0 $version $last_update_token\n";
+my ($version, $time) = @ARGV;
 
 # Check the hook interface version
-if ($version ne 2) {
+
+if ($version == 1) {
+	# convert nanoseconds to seconds
+	# subtract one second to make sure watchman will return all changes
+	$time = int ($time / 1000000000) - 1;
+} else {
 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
 	    "Falling back to scanning...\n";
 }
 
-my $git_work_tree = get_working_dir();
+my $git_work_tree;
+if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+	$git_work_tree = Win32::GetCwd();
+	$git_work_tree =~ tr/\\/\//;
+} else {
+	require Cwd;
+	$git_work_tree = Cwd::cwd();
+}
 
 my $retry = 1;
 
-my $json_pkg;
-eval {
-	require JSON::XS;
-	$json_pkg = "JSON::XS";
-	1;
-} or do {
-	require JSON::PP;
-	$json_pkg = "JSON::PP";
-};
-
 launch_watchman();
 
 sub launch_watchman {
-	my $o = watchman_query();
-	if (is_work_tree_watched($o)) {
-		output_result($o->{clock}, @{$o->{files}});
-	}
-}
-
-sub output_result {
-	my ($clockid, @files) = @_;
-
-	# Uncomment for debugging watchman output
-	# open (my $fh, ">", ".git/watchman-output.out");
-	# binmode $fh, ":utf8";
-	# print $fh "$clockid\n@files\n";
-	# close $fh;
 
-	binmode STDOUT, ":utf8";
-	print $clockid;
-	print "\0";
-	local $, = "\0";
-	print @files;
-}
-
-sub watchman_clock {
-	my $response = qx/watchman clock "$git_work_tree"/;
-	die "Failed to get clock id on '$git_work_tree'.\n" .
-		"Falling back to scanning...\n" if $? != 0;
-
-	return $json_pkg->new->utf8->decode($response);
-}
-
-sub watchman_query {
 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	or die "open2() failed: $!\n" .
-	"Falling back to scanning...\n";
+	    or die "open2() failed: $!\n" .
+	    "Falling back to scanning...\n";
 
 	# In the query expression below we're asking for names of files that
-	# changed since $last_update_token but not from the .git folder.
+	# changed since $time but were not transient (ie created after
+	# $time but no longer exist).
 	#
 	# To accomplish this, we're using the "since" generator to use the
 	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only. Then we're using the "expression" term to
-	# further constrain the results.
-	if (substr($last_update_token, 0, 1) eq "c") {
-		$last_update_token = "\"$last_update_token\"";
-	}
+	# output to file names only.
+
 	my $query = <<"	END";
 		["query", "$git_work_tree", {
-			"since": $last_update_token,
-			"fields": ["name"],
-			"expression": ["not", ["dirname", ".git"]]
+			"since": $time,
+			"fields": ["name"]
 		}]
 	END
 
-	# Uncomment for debugging the watchman query
-	# open (my $fh, ">", ".git/watchman-query.json");
-	# print $fh $query;
-	# close $fh;
-
 	print CHLD_IN $query;
 	close CHLD_IN;
 	my $response = do {local $/; <CHLD_OUT>};
 
-	# Uncomment for debugging the watch response
-	# open ($fh, ">", ".git/watchman-response.json");
-	# print $fh $response;
-	# close $fh;
-
 	die "Watchman: command returned no output.\n" .
-	"Falling back to scanning...\n" if $response eq "";
+	    "Falling back to scanning...\n" if $response eq "";
 	die "Watchman: command returned invalid output: $response\n" .
-	"Falling back to scanning...\n" unless $response =~ /^\{/;
+	    "Falling back to scanning...\n" unless $response =~ /^\{/;
 
-	return $json_pkg->new->utf8->decode($response);
-}
+	my $json_pkg;
+	eval {
+		require JSON::XS;
+		$json_pkg = "JSON::XS";
+		1;
+	} or do {
+		require JSON::PP;
+		$json_pkg = "JSON::PP";
+	};
+
+	my $o = $json_pkg->new->utf8->decode($response);
 
-sub is_work_tree_watched {
-	my ($output) = @_;
-	my $error = $output->{error};
-	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
 		$retry--;
-		my $response = qx/watchman watch "$git_work_tree"/;
+		qx/watchman watch "$git_work_tree"/;
 		die "Failed to make watchman watch '$git_work_tree'.\n" .
 		    "Falling back to scanning...\n" if $? != 0;
-		$output = $json_pkg->new->utf8->decode($response);
-		$error = $output->{error};
-		die "Watchman: $error.\n" .
-		"Falling back to scanning...\n" if $error;
-
-		# Uncomment for debugging watchman output
-		# open (my $fh, ">", ".git/watchman-output.out");
-		# close $fh;
 
 		# Watchman will always return all files on the first query so
 		# return the fast "everything is dirty" flag to git and do the
 		# Watchman query just to get it over with now so we won't pay
 		# the cost in git to look up each individual file.
-		my $o = watchman_clock();
-		$error = $output->{error};
-
-		die "Watchman: $error.\n" .
-		"Falling back to scanning...\n" if $error;
-
-		output_result($o->{clock}, ("/"));
-		$last_update_token = $o->{clock};
-
+		print "/\0";
 		eval { launch_watchman() };
-		return 0;
+		exit 0;
 	}
 
-	die "Watchman: $error.\n" .
-	"Falling back to scanning...\n" if $error;
-
-	return 1;
-}
+	die "Watchman: $o->{error}.\n" .
+	    "Falling back to scanning...\n" if $o->{error};
 
-sub get_working_dir {
-	my $working_dir;
-	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-		$working_dir = Win32::GetCwd();
-		$working_dir =~ tr/\\/\//;
-	} else {
-		require Cwd;
-		$working_dir = Cwd::cwd();
-	}
-
-	return $working_dir;
+	binmode STDOUT, ":utf8";
+	local $, = "\0";
+	print @{$o->{files}};
 }
diff -ruN xv6-public_original/.git/hooks/pre-commit.sample xv6-public_new/.git/hooks/pre-commit.sample
--- xv6-public_original/.git/hooks/pre-commit.sample	2022-08-12 23:03:57.022407000 +0530
+++ xv6-public_new/.git/hooks/pre-commit.sample	2022-10-25 08:09:43.000000000 +0530
@@ -16,7 +16,7 @@
 fi
 
 # If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --type=bool hooks.allownonascii)
+allownonascii=$(git config --bool hooks.allownonascii)
 
 # Redirect output to stderr.
 exec 1>&2
diff -ruN xv6-public_original/.git/hooks/pre-push.sample xv6-public_new/.git/hooks/pre-push.sample
--- xv6-public_original/.git/hooks/pre-push.sample	2022-08-12 23:03:57.022407000 +0530
+++ xv6-public_new/.git/hooks/pre-push.sample	2022-10-25 08:09:43.000000000 +0530
@@ -14,7 +14,7 @@
 # Information about the commits which are being pushed is supplied as lines to
 # the standard input in the form:
 #
-#   <local ref> <local oid> <remote ref> <remote oid>
+#   <local ref> <local sha1> <remote ref> <remote sha1>
 #
 # This sample shows how to prevent push of commits where the log message starts
 # with "WIP" (work in progress).
@@ -22,27 +22,27 @@
 remote="$1"
 url="$2"
 
-zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+z40=0000000000000000000000000000000000000000
 
-while read local_ref local_oid remote_ref remote_oid
+while read local_ref local_sha remote_ref remote_sha
 do
-	if test "$local_oid" = "$zero"
+	if [ "$local_sha" = $z40 ]
 	then
 		# Handle delete
 		:
 	else
-		if test "$remote_oid" = "$zero"
+		if [ "$remote_sha" = $z40 ]
 		then
 			# New branch, examine all commits
-			range="$local_oid"
+			range="$local_sha"
 		else
 			# Update to existing branch, examine new commits
-			range="$remote_oid..$local_oid"
+			range="$remote_sha..$local_sha"
 		fi
 
 		# Check for WIP commit
-		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
-		if test -n "$commit"
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
 		then
 			echo >&2 "Found WIP commit in $local_ref, not pushing"
 			exit 1
diff -ruN xv6-public_original/.git/hooks/push-to-checkout.sample xv6-public_new/.git/hooks/push-to-checkout.sample
--- xv6-public_original/.git/hooks/push-to-checkout.sample	2022-08-12 23:03:57.022407000 +0530
+++ xv6-public_new/.git/hooks/push-to-checkout.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,78 +0,0 @@
-#!/bin/sh
-
-# An example hook script to update a checked-out tree on a git push.
-#
-# This hook is invoked by git-receive-pack(1) when it reacts to git
-# push and updates reference(s) in its repository, and when the push
-# tries to update the branch that is currently checked out and the
-# receive.denyCurrentBranch configuration variable is set to
-# updateInstead.
-#
-# By default, such a push is refused if the working tree and the index
-# of the remote repository has any difference from the currently
-# checked out commit; when both the working tree and the index match
-# the current commit, they are updated to match the newly pushed tip
-# of the branch. This hook is to be used to override the default
-# behaviour; however the code below reimplements the default behaviour
-# as a starting point for convenient modification.
-#
-# The hook receives the commit with which the tip of the current
-# branch is going to be updated:
-commit=$1
-
-# It can exit with a non-zero status to refuse the push (when it does
-# so, it must not modify the index or the working tree).
-die () {
-	echo >&2 "$*"
-	exit 1
-}
-
-# Or it can make any necessary changes to the working tree and to the
-# index to bring them to the desired state when the tip of the current
-# branch is updated to the new commit, and exit with a zero status.
-#
-# For example, the hook can simply run git read-tree -u -m HEAD "$1"
-# in order to emulate git fetch that is run in the reverse direction
-# with git push, as the two-tree form of git read-tree -u -m is
-# essentially the same as git switch or git checkout that switches
-# branches while keeping the local changes in the working tree that do
-# not interfere with the difference between the branches.
-
-# The below is a more-or-less exact translation to shell of the C code
-# for the default behaviour for git's push-to-checkout hook defined in
-# the push_to_deploy() function in builtin/receive-pack.c.
-#
-# Note that the hook will be executed from the repository directory,
-# not from the working tree, so if you want to perform operations on
-# the working tree, you will have to adapt your code accordingly, e.g.
-# by adding "cd .." or using relative paths.
-
-if ! git update-index -q --ignore-submodules --refresh
-then
-	die "Up-to-date check failed"
-fi
-
-if ! git diff-files --quiet --ignore-submodules --
-then
-	die "Working directory has unstaged changes"
-fi
-
-# This is a rough translation of:
-#
-#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
-if git cat-file -e HEAD 2>/dev/null
-then
-	head=HEAD
-else
-	head=$(git hash-object -t tree --stdin </dev/null)
-fi
-
-if ! git diff-index --quiet --cached --ignore-submodules $head --
-then
-	die "Working directory has staged changes"
-fi
-
-if ! git read-tree -u -m "$commit"
-then
-	die "Could not update working tree to new HEAD"
-fi
diff -ruN xv6-public_original/.git/hooks/update.sample xv6-public_new/.git/hooks/update.sample
--- xv6-public_original/.git/hooks/update.sample	2022-08-12 23:03:57.022407000 +0530
+++ xv6-public_new/.git/hooks/update.sample	2022-10-25 08:09:43.000000000 +0530
@@ -43,11 +43,11 @@
 fi
 
 # --- Config
-allowunannotated=$(git config --type=bool hooks.allowunannotated)
-allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
-allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
-allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
 
 # check for no description
 projectdesc=$(sed -e '1q' "$GIT_DIR/description")
@@ -60,7 +60,7 @@
 
 # --- Check types
 # if $newrev is 0000...0000, it's a commit to delete a ref.
-zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+zero="0000000000000000000000000000000000000000"
 if [ "$newrev" = "$zero" ]; then
 	newrev_type=delete
 else
Binary files xv6-public_original/.git/index and xv6-public_new/.git/index differ
diff -ruN xv6-public_original/.git/logs/HEAD xv6-public_new/.git/logs/HEAD
--- xv6-public_original/.git/logs/HEAD	2022-08-12 23:04:14.366780000 +0530
+++ xv6-public_new/.git/logs/HEAD	2022-10-25 08:09:59.000000000 +0530
@@ -1 +1 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Pranshu Shah <shahpranshu12@gmail.com> 1660325654 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vedant Shah <vedant@vedant-VirtualBox.(none)> 1666665599 +0530	clone: from https://github.com/mit-pdos/xv6-public
diff -ruN xv6-public_original/.git/logs/refs/heads/master xv6-public_new/.git/logs/refs/heads/master
--- xv6-public_original/.git/logs/refs/heads/master	2022-08-12 23:04:14.366780000 +0530
+++ xv6-public_new/.git/logs/refs/heads/master	2022-10-25 08:09:59.000000000 +0530
@@ -1 +1 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Pranshu Shah <shahpranshu12@gmail.com> 1660325654 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vedant Shah <vedant@vedant-VirtualBox.(none)> 1666665599 +0530	clone: from https://github.com/mit-pdos/xv6-public
diff -ruN xv6-public_original/.git/logs/refs/remotes/origin/HEAD xv6-public_new/.git/logs/refs/remotes/origin/HEAD
--- xv6-public_original/.git/logs/refs/remotes/origin/HEAD	2022-08-12 23:04:14.366780000 +0530
+++ xv6-public_new/.git/logs/refs/remotes/origin/HEAD	2022-10-25 08:09:59.000000000 +0530
@@ -1 +1 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Pranshu Shah <shahpranshu12@gmail.com> 1660325654 +0530	clone: from https://github.com/mit-pdos/xv6-public.git
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 Vedant Shah <vedant@vedant-VirtualBox.(none)> 1666665599 +0530	clone: from https://github.com/mit-pdos/xv6-public
Binary files xv6-public_original/.git/objects/pack/pack-c6e0cd30f0b86ac0699382211cda02e663cb29d2.idx and xv6-public_new/.git/objects/pack/pack-c6e0cd30f0b86ac0699382211cda02e663cb29d2.idx differ
Binary files xv6-public_original/.git/objects/pack/pack-c6e0cd30f0b86ac0699382211cda02e663cb29d2.pack and xv6-public_new/.git/objects/pack/pack-c6e0cd30f0b86ac0699382211cda02e663cb29d2.pack differ
Binary files xv6-public_original/.git/objects/pack/pack-df231414196a28fc988083de319039681dd68d80.idx and xv6-public_new/.git/objects/pack/pack-df231414196a28fc988083de319039681dd68d80.idx differ
Binary files xv6-public_original/.git/objects/pack/pack-df231414196a28fc988083de319039681dd68d80.pack and xv6-public_new/.git/objects/pack/pack-df231414196a28fc988083de319039681dd68d80.pack differ
diff -ruN xv6-public_original/kalloc.c xv6-public_new/kalloc.c
--- xv6-public_original/kalloc.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/kalloc.c	2022-10-31 13:45:00.000000000 +0530
@@ -8,19 +8,20 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "spinlock.h"
+#include "proc.h"
 
 void freerange(void *vstart, void *vend);
 extern char end[]; // first address after kernel loaded from ELF file
                    // defined by the kernel linker script in kernel.ld
 
-struct run {
+struct run {          
   struct run *next;
 };
 
-struct {
+struct {            
   struct spinlock lock;
   int use_lock;
-  struct run *freelist;
+  struct run *freelist; 
 } kmem;
 
 // Initialization happens in two phases.
@@ -59,13 +60,19 @@
 void
 kfree(char *v)
 {
+
   struct run *r;
+  // struct proc *p=myproc();
 
-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP){
     panic("kfree");
+  }
 
   // Fill with junk to catch dangling refs.
-  memset(v, 1, PGSIZE);
+  // memset(v, 1, PGSIZE);
+  for(int i=0;i<PGSIZE;i++){
+    v[i]=1;
+  }
 
   if(kmem.use_lock)
     acquire(&kmem.lock);
@@ -74,6 +81,17 @@
   kmem.freelist = r;
   if(kmem.use_lock)
     release(&kmem.lock);
+
+  //Wake up processes sleeping on sleeping channel.
+  if(kmem.use_lock)
+    acquire(&sleeping_channel_lock);
+  if(sleeping_channel_count){
+    wakeup(sleeping_channel);
+    sleeping_channel_count=0;
+  }
+  if(kmem.use_lock)
+    release(&sleeping_channel_lock);
+
 }
 
 // Allocate one 4096-byte page of physical memory.
@@ -93,4 +111,3 @@
     release(&kmem.lock);
   return (char*)r;
 }
-
diff -ruN xv6-public_original/main.c xv6-public_new/main.c
--- xv6-public_original/main.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/main.c	2022-10-31 13:45:35.000000000 +0530
@@ -14,6 +14,7 @@
 // Bootstrap processor starts running C code here.
 // Allocate a real stack and switch to it, first
 // doing some setup required for memory allocator to work.
+
 int
 main(void)
 {
@@ -30,11 +31,13 @@
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
-  ideinit();       // disk 
+  ideinit();       // disk
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
+  // create_kernel_process("swap_out_process", &swap_out_process_function);
   mpmain();        // finish this processor's setup
+
 }
 
 // Other CPUs jump here from entryother.S.
@@ -113,4 +116,3 @@
 // Blank page.
 //PAGEBREAK!
 // Blank page.
-
diff -ruN xv6-public_original/Makefile xv6-public_new/Makefile
--- xv6-public_original/Makefile	2022-08-12 23:04:14.366780000 +0530
+++ xv6-public_new/Makefile	2022-10-31 13:43:05.000000000 +0530
@@ -143,7 +143,7 @@
 vectors.S: vectors.pl
 	./vectors.pl > vectors.S
 
-ULIB = ulib.o usys.o printf.o umalloc.o
+ULIB = ulib.o usys.o printf.o umalloc.o random.o
 
 _%: %.o $(ULIB)
 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
@@ -181,6 +181,7 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_memtest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -249,8 +250,8 @@
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c memtest.c\
+	printf.c umalloc.c random.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
@@ -283,4 +284,4 @@
 	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
 	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
 
-.PHONY: dist-test dist
+.PHONY: dist-test dist
\ No newline at end of file
diff -ruN xv6-public_original/memtest.c xv6-public_new/memtest.c
--- xv6-public_original/memtest.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/memtest.c	2022-10-31 22:42:40.000000000 +0530
@@ -0,0 +1,48 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define PGSIZE 4096
+#define ITERATIONS 10
+#define CHILDREN 20
+
+
+void child_process(int i){
+	char *ptr[ITERATIONS];
+
+	for(int j=0;j<ITERATIONS;j++){
+		// set all values
+		ptr[j]=(char*)malloc(PGSIZE);
+		for(int k=0;k<(PGSIZE);k++){
+			ptr[j][k]=(i+j*k)%128;
+		}
+
+		int matched=0;
+		// check all values
+		for(int k=0;k<(PGSIZE);k++){
+			if(ptr[j][k]==(i+j*k)%128){
+				matched++;
+			}
+		}
+		printf(1, "Process: %d\tIteration: %d\tMatched: %dB\tDifferent: %dB\n",i+1, j+1, matched, 4096-matched);
+	}
+
+}
+
+int
+main(int argc, char* argv[]){
+
+	for(int i=0;i<CHILDREN;i++){
+		if(!fork()){
+			
+			child_process(i);
+
+			printf(1, "\n");
+			exit();
+		}
+	}
+
+	while(wait()!=-1);
+	exit();
+
+}
\ No newline at end of file
diff -ruN xv6-public_original/mmu.h xv6-public_new/mmu.h
--- xv6-public_original/mmu.h	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/mmu.h	2022-10-31 13:46:37.000000000 +0530
@@ -94,6 +94,7 @@
 #define PTE_P           0x001   // Present
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
+#define PTE_A           0x020   // Accessed
 #define PTE_PS          0x080   // Page Size
 
 // Address in page table or page directory entry
@@ -178,4 +179,4 @@
   (gate).off_31_16 = (uint)(off) >> 16;                  \
 }
 
-#endif
+#endif
\ No newline at end of file
diff -ruN xv6-public_original/param.h xv6-public_new/param.h
--- xv6-public_original/param.h	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/param.h	2022-10-31 13:46:54.000000000 +0530
@@ -1,6 +1,6 @@
 #define NPROC        64  // maximum number of processes
 #define KSTACKSIZE 4096  // size of per-process kernel stack
-#define NCPU          8  // maximum number of CPUs
+#define NCPU          1  // maximum number of CPUs
 #define NOFILE       16  // open files per process
 #define NFILE       100  // open files per system
 #define NINODE       50  // maximum number of active i-nodes
@@ -11,4 +11,3 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
-
diff -ruN xv6-public_original/proc.c xv6-public_new/proc.c
--- xv6-public_original/proc.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/proc.c	2022-10-31 23:44:03.089913879 +0530
@@ -3,9 +3,369 @@
 #include "param.h"
 #include "memlayout.h"
 #include "mmu.h"
+#include "stat.h"
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "fcntl.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "file.h"
+
+int swap_out_process_exists=0;
+int swap_in_process_exists=0;
+
+int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);
+
+int
+proc_close(int fd)
+{
+  struct file *f;
+
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+    return -1;
+  
+  myproc()->ofile[fd] = 0;
+  fileclose(f);
+  return 0;
+}
+
+int
+proc_write(int fd, char *p, int n)
+{
+  struct file *f;
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+    return -1;
+  return filewrite(f, p, n);
+}
+
+
+static struct inode*
+proc_create(char *path, short type, short major, short minor)
+{
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+    return 0;
+  ilock(dp);
+
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    iunlockput(dp);
+    ilock(ip);
+    if(type == T_FILE && ip->type == T_FILE)
+      return ip;
+    iunlockput(ip);
+    return 0;
+  }
+
+  if((ip = ialloc(dp->dev, type)) == 0)
+    panic("create: ialloc");
+
+  ilock(ip);
+  ip->major = major;
+  ip->minor = minor;
+  ip->nlink = 1;
+  iupdate(ip);
+
+  if(type == T_DIR){  // Create . and .. entries.
+    dp->nlink++;  // for ".."
+    iupdate(dp);
+    // No ip->nlink++ for ".": avoid cyclic ref count.
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+      panic("create dots");
+  }
+
+  if(dirlink(dp, name, ip->inum) < 0)
+    panic("create: dirlink");
+
+  iunlockput(dp);
+
+  return ip;
+}
+
+
+static int
+proc_fdalloc(struct file *f)
+{
+  int fd;
+  struct proc *curproc = myproc();
+
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd] == 0){
+      curproc->ofile[fd] = f;
+      return fd;
+    }
+  }
+  return -1;
+}
+
+int proc_open(char *path, int omode){
+
+  int fd;
+  struct file *f;
+  struct inode *ip;
+
+  begin_op();
+
+  if(omode & O_CREATE){
+    ip = proc_create(path, T_FILE, 0, 0);
+    if(ip == 0){
+      end_op();
+      return -1;
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+      end_op();
+      return -1;
+    }
+    ilock(ip);
+    if(ip->type == T_DIR && omode != O_RDONLY){
+      iunlockput(ip);
+      end_op();
+      return -1;
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = proc_fdalloc(f)) < 0){
+    if(f)
+      fileclose(f);
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+  end_op();
+
+  f->type = FD_INODE;
+  f->ip = ip;
+  f->off = 0;
+  f->readable = !(omode & O_WRONLY);
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+  return fd;
+
+}
+
+void int_to_string(int x, char *c){
+  if(x==0)
+  {
+    c[0]='0';
+    c[1]='\0';
+    return;
+  }
+  int i=0;
+  while(x>0){
+    c[i]=x%10+'0';
+    i++;
+    x/=10;
+  }
+  c[i]='\0';
+
+  for(int j=0;j<i/2;j++){
+    char a=c[j];
+    c[j]=c[i-j-1];
+    c[i-j-1]=a;
+  }
+
+}
+
+struct req_queue{
+  struct spinlock lock;
+  struct proc* queue[NPROC];
+  int s;
+  int e;
+};
+
+//circular request queue for swapping out requests.
+struct req_queue queue1;
+
+struct proc* rpop(){
+
+  acquire(&queue1.lock);
+  if(queue1.s==queue1.e){
+  	release(&queue1.lock);
+  	return 0;
+  }
+  struct proc *p=queue1.queue[queue1.s];
+  (queue1.s)++;
+  (queue1.s)%=NPROC;
+  release(&queue1.lock);
+
+  return p;
+}
+
+int rpush(struct proc *p){
+
+  acquire(&queue1.lock);
+  if((queue1.e+1)%NPROC==queue1.s){
+  	release(&queue1.lock);
+    return 0;
+  }
+  queue1.queue[queue1.e]=p;
+  queue1.e++;
+  (queue1.e)%=NPROC;
+  release(&queue1.lock);
+  
+  return 1;
+}
+
+//circular request queue for swapping in requests
+struct req_queue queue2;
+
+struct proc* rpop2(){
+
+	acquire(&queue2.lock);
+	if(queue2.s==queue2.e){
+		release(&queue2.lock);
+		return 0;
+	}
+	struct proc* p=queue2.queue[queue2.s];
+	(queue2.s)++;
+	(queue2.s)%=NPROC;
+	release(&queue2.lock);
+	return p;
+}
+
+int rpush2(struct proc* p){
+	acquire(&queue2.lock);
+	if((queue2.e+1)%NPROC==queue2.s){
+		release(&queue2.lock);
+		return 0;
+	}
+	queue2.queue[queue2.e]=p;
+	(queue2.e)++;
+	(queue2.e)%=NPROC;
+
+	release(&queue2.lock);
+	return 1;
+}
+
+ 
+void swap_out_process_function(){
+
+  acquire(&queue1.lock);
+  while(queue1.s!=queue1.e){
+    struct proc *p=rpop();
+
+    pde_t* pd = p->pgdir;
+    for(int i=0;i<NPDENTRIES;i++){
+
+      //skip page table if accessed. chances are high, not every page table was accessed.
+      if(pd[i]&PTE_A)
+        continue;
+      //else
+      pte_t *pgtab = (pte_t*)P2V(PTE_ADDR(pd[i]));
+      for(int j=0;j<NPTENTRIES;j++){
+
+        //Skip if found
+        if((pgtab[j]&PTE_A) || !(pgtab[j]&PTE_P))
+          continue;
+        pte_t *pte=(pte_t*)P2V(PTE_ADDR(pgtab[j]));
+
+        //for file name
+        int pid=p->pid;
+        int virt = ((1<<22)*i)+((1<<12)*j);
+
+        //file name
+        char c[50];
+        int_to_string(pid,c);
+        int x=strlen(c);
+        c[x]='_';
+        int_to_string(virt,c+x+1);
+        safestrcpy(c+strlen(c),".swp",5);
+
+        // file management
+        int fd=proc_open(c, O_CREATE | O_RDWR);
+        if(fd<0){
+          cprintf("error creating or opening file: %s\n", c);
+          panic("swap_out_process");
+        }
+
+        if(proc_write(fd,(char *)pte, PGSIZE) != PGSIZE){
+          cprintf("error writing to file: %s\n", c);
+          panic("swap_out_process");
+        }
+        proc_close(fd);
+
+        kfree((char*)pte);
+        memset(&pgtab[j],0,sizeof(pgtab[j]));
+
+        //mark this page as being swapped out.
+        pgtab[j]=((pgtab[j])^(0x080));
+
+        break;
+      }
+    }
+
+  }
+
+  release(&queue1.lock);
+  
+  struct proc *p;
+  if((p=myproc())==0)
+    panic("swap out process");
+
+  swap_out_process_exists=0;
+  p->parent = 0;
+  p->name[0] = '*';
+  p->killed = 0;
+  p->state = UNUSED;
+  sched();
+}
+
+int proc_read(int fd, int n, char *p)
+{
+  struct file *f;
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+  return -1;
+  return fileread(f, p, n);
+
+}
+
+void swap_in_process_function(){
+
+	acquire(&queue2.lock);
+	while(queue2.s!=queue2.e){
+		struct proc *p=rpop2();
+
+		int pid=p->pid;
+		int virt=PTE_ADDR(p->addr);
+
+		char c[50];
+	    int_to_string(pid,c);
+	    int x=strlen(c);
+	    c[x]='_';
+	    int_to_string(virt,c+x+1);
+	    safestrcpy(c+strlen(c),".swp",5);
+
+	    int fd=proc_open(c,O_RDONLY);
+	    if(fd<0){
+	    	release(&queue2.lock);
+	    	cprintf("could not find page file in memory: %s\n", c);
+	    	panic("swap_in_process");
+	    }
+	    char *mem=kalloc();
+	    proc_read(fd,PGSIZE,mem);
+
+	    if(mappages(p->pgdir, (void *)virt, PGSIZE, V2P(mem), PTE_W|PTE_U)<0){
+	    	release(&queue2.lock);
+	    	panic("mappages");
+	    }
+	    wakeup(p);
+	}
+
+    release(&queue2.lock);
+    struct proc *p;
+	if((p=myproc())==0)
+	  panic("swap_in_process");
+
+	swap_in_process_exists=0;
+	p->parent = 0;
+	p->name[0] = '*';
+	p->killed = 0;
+	p->state = UNUSED;
+	sched();
+}
 
 struct {
   struct spinlock lock;
@@ -24,6 +384,9 @@
 pinit(void)
 {
   initlock(&ptable.lock, "ptable");
+  initlock(&queue1.lock, "queue1");
+  initlock(&sleeping_channel_lock, "sleeping_channel");
+  initlock(&queue2.lock, "queue2");
 }
 
 // Must be called with interrupts disabled
@@ -115,11 +478,46 @@
   return p;
 }
 
+void create_kernel_process(const char *name, void (*entrypoint)()){
+    
+  struct proc *p = allocproc();
+
+  if(p == 0)
+    panic("create_kernel_process failed");
+
+  //Setting up kernel page table using setupkvm
+  if((p->pgdir = setupkvm()) == 0)
+    panic("setupkvm failed");
+
+  //This is a kernel process. Trap frame stores user space registers. We don't need to initialise tf.
+  //Also, since this doesn't need to have a userspace, we don't need to assign a size to this process.
+
+  //eip stores address of next instruction to be executed
+  p->context->eip = (uint)entrypoint;
+
+  safestrcpy(p->name, name, sizeof(p->name));
+
+  acquire(&ptable.lock);
+  p->state = RUNNABLE;
+  release(&ptable.lock);
+
+}
+
 //PAGEBREAK: 32
 // Set up first user process.
 void
 userinit(void)
 {
+  acquire(&queue1.lock);
+  queue1.s=0;
+  queue1.e=0;
+  release(&queue1.lock);
+
+  acquire(&queue2.lock);
+  queue2.s=0;
+  queue2.e=0;
+  release(&queue2.lock);
+
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
@@ -151,6 +549,7 @@
   p->state = RUNNABLE;
 
   release(&ptable.lock);
+
 }
 
 // Grow current process's memory by n bytes.
@@ -180,6 +579,7 @@
 int
 fork(void)
 {
+
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
@@ -227,6 +627,7 @@
 void
 exit(void)
 {
+
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
@@ -242,6 +643,7 @@
     }
   }
 
+
   begin_op();
   iput(curproc->cwd);
   end_op();
@@ -333,9 +735,36 @@
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+
+      //If the swap out process has stopped running, free its stack and name.
+      if(p->state==UNUSED && p->name[0]=='*'){
+
+        kfree(p->kstack);
+        p->kstack=0;
+        p->name[0]=0;
+        p->pid=0;
+      }
+
       if(p->state != RUNNABLE)
         continue;
 
+      for(int i=0;i<NPDENTRIES;i++){
+        //If PDE was accessed
+
+        if(((p->pgdir)[i])&PTE_P && ((p->pgdir)[i])&PTE_A){
+
+          pte_t* pgtab = (pte_t*)P2V(PTE_ADDR((p->pgdir)[i]));
+
+          for(int j=0;j<NPTENTRIES;j++){
+            if(pgtab[j]&PTE_A){
+              pgtab[j]^=PTE_A;
+            }
+          }
+
+          ((p->pgdir)[i])^=PTE_A;
+        }
+      }
+
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
@@ -365,6 +794,7 @@
 void
 sched(void)
 {
+
   int intena;
   struct proc *p = myproc();
 
@@ -531,4 +961,4 @@
     }
     cprintf("\n");
   }
-}
+}
\ No newline at end of file
diff -ruN xv6-public_original/proc.h xv6-public_new/proc.h
--- xv6-public_original/proc.h	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/proc.h	2022-10-31 13:47:27.000000000 +0530
@@ -49,10 +49,12 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int addr;                    // ADDED: Virtual address of pagefault
+
 };
 
 // Process memory is laid out contiguously, low addresses first:
 //   text
 //   original data and bss
 //   fixed-size stack
-//   expandable heap
+//   expandable heap
\ No newline at end of file
diff -ruN xv6-public_original/random.c xv6-public_new/random.c
--- xv6-public_original/random.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/random.c	2022-10-31 13:47:56.000000000 +0530
@@ -0,0 +1,101 @@
+/* Period parameters */  
+#define N 624
+#define M 397
+#define MATRIX_A 0x9908b0df   /* constant vector a */
+#define UPPER_MASK 0x80000000 /* most significant w-r bits */
+#define LOWER_MASK 0x7fffffff /* least significant r bits */
+
+/* Tempering parameters */   
+#define TEMPERING_MASK_B 0x9d2c5680
+#define TEMPERING_MASK_C 0xefc60000
+#define TEMPERING_SHIFT_U(y)  (y >> 11)
+#define TEMPERING_SHIFT_S(y)  (y << 7)
+#define TEMPERING_SHIFT_T(y)  (y << 15)
+#define TEMPERING_SHIFT_L(y)  (y >> 18)
+
+#define RAND_MAX 0x7fffffff
+
+static unsigned long mt[N]; /* the array for the state vector  */
+static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */
+
+/* initializing the array with a NONZERO seed */
+void
+sgenrand(unsigned long seed)
+{
+    /* setting initial seeds to mt[N] using         */
+    /* the generator Line 25 of Table 1 in          */
+    /* [KNUTH 1981, The Art of Computer Programming */
+    /*    Vol. 2 (2nd Ed.), pp102]                  */
+    mt[0]= seed & 0xffffffff;
+    for (mti=1; mti<N; mti++)
+        mt[mti] = (69069 * mt[mti-1]) & 0xffffffff;
+}
+
+long /* for integer generation */
+genrand()
+{
+    unsigned long y;
+    static unsigned long mag01[2]={0x0, MATRIX_A};
+    /* mag01[x] = x * MATRIX_A  for x=0,1 */
+
+    if (mti >= N) { /* generate N words at one time */
+        int kk;
+
+        if (mti == N+1)   /* if sgenrand() has not been called, */
+            sgenrand(4357); /* a default initial seed is used   */
+
+        for (kk=0;kk<N-M;kk++) {
+            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
+            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
+        }
+        for (;kk<N-1;kk++) {
+            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
+            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
+        }
+        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
+        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];
+
+        mti = 0;
+    }
+  
+    y = mt[mti++];
+    y ^= TEMPERING_SHIFT_U(y);
+    y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;
+    y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;
+    y ^= TEMPERING_SHIFT_L(y);
+
+    // Strip off uppermost bit because we want a long,
+    // not an unsigned long
+    return y & RAND_MAX;
+}
+
+// Assumes 0 <= max <= RAND_MAX
+// Returns in the half-open interval [0, max]
+long random_at_most(long max) {
+  unsigned long
+    // max <= RAND_MAX < ULONG_MAX, so this is okay.
+    num_bins = (unsigned long) max + 1,
+    num_rand = (unsigned long) RAND_MAX + 1,
+    bin_size = num_rand / num_bins,
+    defect   = num_rand % num_bins;
+
+  long x;
+  do {
+   x = genrand();
+  }
+  // This is carefully written not to overflow
+  while (num_rand - defect <= (unsigned long)x);
+
+  // Truncated division is intentional
+  return x/bin_size;
+}
+
+int randomrange(int low, int high){
+  if(high<low){
+    int temp=high;
+    high=low;
+    low=temp;
+  }
+  int val = random_at_most(high-low) + low;
+  return val;
+}
\ No newline at end of file
diff -ruN xv6-public_original/sleeplock.c xv6-public_new/sleeplock.c
--- xv6-public_original/sleeplock.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/sleeplock.c	2022-10-31 13:48:17.000000000 +0530
@@ -22,10 +22,13 @@
 void
 acquiresleep(struct sleeplock *lk)
 {
+
   acquire(&lk->lk);
+
   while (lk->locked) {
     sleep(lk, &lk->lk);
   }
+
   lk->locked = 1;
   lk->pid = myproc()->pid;
   release(&lk->lk);
@@ -53,4 +56,3 @@
 }
 
 
-
diff -ruN xv6-public_original/spinlock.c xv6-public_new/spinlock.c
--- xv6-public_original/spinlock.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/spinlock.c	2022-10-31 13:48:35.000000000 +0530
@@ -25,6 +25,7 @@
 acquire(struct spinlock *lk)
 {
   pushcli(); // disable interrupts to avoid deadlock.
+
   if(holding(lk))
     panic("acquire");
 
@@ -123,4 +124,3 @@
   if(mycpu()->ncli == 0 && mycpu()->intena)
     sti();
 }
-
diff -ruN xv6-public_original/trap.c xv6-public_new/trap.c
--- xv6-public_original/trap.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/trap.c	2022-10-31 13:48:56.000000000 +0530
@@ -14,6 +14,30 @@
 struct spinlock tickslock;
 uint ticks;
 
+struct spinlock swap_in_lock;
+
+void handlePageFault(){
+  int addr=rcr2();
+  struct proc *p=myproc();
+  acquire(&swap_in_lock);
+  sleep(p,&swap_in_lock);
+  pde_t *pde = &(p->pgdir)[PDX(addr)];
+  pte_t *pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+
+  if((pgtab[PTX(addr)])&0x080){
+    //This means that the page was swapped out.
+    //virtual address for page
+    p->addr = addr;
+    rpush2(p);
+    if(!swap_in_process_exists){
+      swap_in_process_exists=1;
+      create_kernel_process("swap_in_process", &swap_in_process_function);
+    }
+  } else {
+    exit();
+  }
+}
+
 void
 tvinit(void)
 {
@@ -77,7 +101,9 @@
             cpuid(), tf->cs, tf->eip);
     lapiceoi();
     break;
-
+  case T_PGFLT:
+    handlePageFault();
+  break;
   //PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
@@ -102,11 +128,11 @@
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+  // if(myproc() && myproc()->state == RUNNING &&
+  //    tf->trapno == T_IRQ0+IRQ_TIMER)
+  //   yield();
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
-}
+}
\ No newline at end of file
diff -ruN xv6-public_original/ulib.c xv6-public_new/ulib.c
--- xv6-public_original/ulib.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/ulib.c	2022-10-31 13:49:09.000000000 +0530
@@ -36,6 +36,7 @@
 void*
 memset(void *dst, int c, uint n)
 {
+
   stosb(dst, c, n);
   return dst;
 }
@@ -103,4 +104,4 @@
   while(n-- > 0)
     *dst++ = *src++;
   return vdst;
-}
+}
\ No newline at end of file
diff -ruN xv6-public_original/user.h xv6-public_new/user.h
--- xv6-public_original/user.h	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/user.h	2022-10-31 13:49:22.000000000 +0530
@@ -37,3 +37,4 @@
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+int randomrange(int, int);
\ No newline at end of file
diff -ruN xv6-public_original/vm.c xv6-public_new/vm.c
--- xv6-public_original/vm.c	2022-08-12 23:04:14.370780000 +0530
+++ xv6-public_new/vm.c	2022-10-31 13:49:36.000000000 +0530
@@ -6,10 +6,15 @@
 #include "mmu.h"
 #include "proc.h"
 #include "elf.h"
+#include "spinlock.h"
 
 extern char data[];  // defined by kernel.ld
 pde_t *kpgdir;  // for use in scheduler()
 
+struct spinlock sleeping_channel_lock;
+int sleeping_channel_count=0;
+char * sleeping_channel;
+
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
 void
@@ -57,7 +62,7 @@
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
-static int
+int
 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 {
   char *a, *last;
@@ -233,8 +238,22 @@
   for(; a < newsz; a += PGSIZE){
     mem = kalloc();
     if(mem == 0){
-      cprintf("allocuvm out of memory\n");
+      // cprintf("allocuvm out of memory\n");
       deallocuvm(pgdir, newsz, oldsz);
+
+      //SLEEP
+      myproc()->state=SLEEPING;
+      acquire(&sleeping_channel_lock);
+      myproc()->chan=sleeping_channel;
+      sleeping_channel_count++;
+      release(&sleeping_channel_lock);
+
+	     rpush(myproc());
+      if(!swap_out_process_exists){
+        swap_out_process_exists=1;
+        create_kernel_process("swap_out_process", &swap_out_process_function);
+      }
+      
       return 0;
     }
     memset(mem, 0, PGSIZE);
@@ -391,4 +410,3 @@
 // Blank page.
 //PAGEBREAK!
 // Blank page.
-
diff -ruN xv6-public_original/.vscode/settings.json xv6-public_new/.vscode/settings.json
--- xv6-public_original/.vscode/settings.json	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/.vscode/settings.json	2022-10-31 13:36:36.000000000 +0530
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "memlayout.h": "c"
+    }
+}
\ No newline at end of file
